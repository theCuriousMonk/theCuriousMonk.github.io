<!DOCTYPE html><html lang="en">
<!-- Mirrored from javascript.info/promise-chaining by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 10 Sep 2018 10:51:37 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><script>window.currentUser = null;</script><title itemprop="name">Promises chaining</title><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes, minimum-scale=1.0"><meta name="apple-mobile-web-app-capable" content="yes"><script>if (window.devicePixelRatio > 1) document.cookie = 'pixelRatio=' + window.devicePixelRatio + ';path=/;expires=Tue, 19 Jan 2038 03:14:07 GMT';</script><link href="http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,400,700%7COpen+Sans+Condensed:700&amp;subset=latin,latin-ext,cyrillic,cyrillic-ext" rel="stylesheet"><link rel="apple-touch-icon-precomposed" href="img/favicon/apple-touch-icon-precomposed.png"><link rel="canonical" href="promise-chaining.html"><meta name="msapplication-TileColor" content="#222A2C"><meta name="msapplication-TileImage" content="/img/favicon/tileicon.png"><!-- favicon the rest--><link rel="icon" href="img/favicon/favicon.png"><meta itemprop="image" content="https://javascript.info/img/site_preview_en_512x512.png"><meta property="og:title" content="Promises chaining"><meta property="og:image" content="https://javascript.info/img/site_preview_en_1200x630.png"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="fb:admins" content="100001562528165"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Promises chaining"><meta name="twitter:site" content="@iliakan"><meta name="twitter:creator" content="@iliakan"><meta name="twitter:image" content="https://javascript.info/img/site_preview_en_512x512.png"><link href="pack/styles.b363cbd7204b6ec74a4cbeca7061b31d.css" rel="stylesheet"><link rel="prev" href="promise-basics.html"><link rel="next" href="promise-api.html"><script>window.GA_ID = "UA-2056213-15";</script><script>window.YANDEX_METRIKA_ID = 32184394;</script><script>window.GoogleAnalyticsObject="ga",window.ga=function(){window.ga.q.push(arguments)},window.ga.q=[],window.ga.l=Date.now(),ga("create",GA_ID,"auto"),window.currentUser?ga("set","&uid",currentUser.id):ga("set","anonymizeIp",!0),window.addEventListener("error",function(e){var n=(e.filename||e.errorUrl)+": "+(e.lineno||e.errorLine),r=e.stack||e.error&&e.error.stack;ga("send","exception",{exDescription:e.message+" "+n+" "+r,exFatal:!0})});</script><script src="../www.google-analytics.com/analytics.js" async></script><script>ga('send', 'pageview');</script><script>window.metrika={reachGoal:function(){}},window.yandex_metrika_callbacks=[function(){try{window.metrika=new Ya.Metrika({id:YANDEX_METRIKA_ID,webvisor:!0,clickmap:!0,params:{user:window.currentUser&&window.currentUser.id}}),metrika.trackLinks({delay:150}),window.addEventListener("error",function(r){window.metrika.reachGoal("JSERROR",{src:(r.filename||r.errorUrl)+": "+(r.lineno||r.errorLine),stack:r.stack||r.error&&r.error.stack,message:r.message})})}catch(r){}}];</script><script src="../mc.yandex.ru/metrika/watch.js" async></script><script>window.RECAPTCHA_ID = "6Lf9NyETAAAAACZlg-a9Us2SxvYbeVC1ROWaWv4O";</script><script src="inite4da.js?5"></script><script src="pack/head.5ac6aee21473ea597203.js" defer></script><script>
function loadScript(src) {
  return new Promise(function(resolve, reject) {
    let script = document.createElement('script');
    script.src = src;

    script.onload = () => resolve(script);
    script.onerror = () => reject(new Error("Script load error: " + src));

    document.head.append(script);
  });
}

class HttpError extends Error {
  constructor(response) {
    super(`${response.status} for ${response.url}`);
    this.name = 'HttpError';
    this.response = response;
  }
}

function loadJson(url) {
  return fetch(url)
    .then(response => {
      if (response.status == 200) {
        return response.json();
      } else {
        throw new HttpError(response);
      }
    })
}
</script>

<style>
.promise-avatar-example {
  border-radius: 50%;
  position: fixed;
  left: 10px;
  top: 10px;
}
</style>
<meta property="og:title" content="Promises chaining"><meta property="og:type" content="article"><script src="pack/tutorial.5ac6aee21473ea597203.js" defer></script><script src="pack/footer.5ac6aee21473ea597203.js" defer></script></head><body class="no-icons"><script>window.fontTest();</script><div class="page-wrapper page-wrapper_sidebar_on"><!--[if lt IE 10]><div style="color:red;text-align:center">Sorry, IE&lt;10 is not supported, please use a newer browser.</div><![endif]--><div class="sitetoolbar sitetoolbar_tutorial"><div style="display:none" id="notify-en-tutorial" class="notification notification_info notification_top sitetoolbar__notification"><div class="notification__content">The tutorial was recently rewritten from scratch. There may be typos, please use the "Edit on Github" link (in left sidebar in an article, at the bottom) to propose fixes.
Thank you!</div><button title="Close" class="notification__close"></button></div><script>showTopNotification();</script><div class="sitetoolbar__content"><div class="sitetoolbar__logo-wrap"><a href="index.html" class="sitetoolbar__link sitetoolbar__link_logo"><img src="img/sitetoolbar__logo_en.svg" width="200" class="sitetoolbar__logo sitetoolbar__logo_normal" alt=""><img src="img/sitetoolbar__logo_small_en.svg" width="70" class="sitetoolbar__logo sitetoolbar__logo_small" alt=""><script>Array.prototype.forEach.call(document.querySelectorAll("img.sitetoolbar__logo"),function(e){var t=document.createElement("object");t.type="image/svg+xml",t.className=e.className,t.style.cssText="left:0;top:0;position:absolute",t.onload=function(){t.onload=null,e.style.visibility="hidden"},t.data=e.src,e.parentNode.insertBefore(t,e)});</script></a></div><div class="sitetoolbar__nav-toggle-wrap"><button type="button" class="sitetoolbar__nav-toggle"></button></div><nav class="sitetoolbar__sections"><ul class="sitetoolbar__sections-list"><li class="sitetoolbar__section sitetoolbar__section_current"><a href="index.html" class="sitetoolbar__link">Tutorial</a></li><li class="sitetoolbar__section"><a href="courses.html" class="sitetoolbar__link">Courses</a></li></ul></nav><div class="sitetoolbar__book-wrap"><a href="ebook.html" class="buy-book-button"><span class="buy-book-button__extra-text">Buy</span>EPUB/PDF</a></div><div class="sitetoolbar__login-wrap"><button data-action-login class="sitetoolbar__login sitetoolbar__login_unready"></button></div><div class="sitetoolbar__search-wrap"><div class="sitetoolbar__search-content"><form method="GET" action="http://javascript.info/search" class="sitetoolbar__search"><button type="button" class="sitetoolbar__search-toggle"></button><div class="sitetoolbar__search-input"><div class="text-input"><input autofocus name="query" placeholder="Search on Javascript.info" class="text-input__control" type="text"></div><button type="submit" class="sitetoolbar__find">Search</button></div></form></div></div></div><!-- todo: en variant--><div class="tablet-menu"><div class="tablet-menu__line"><div class="tablet-menu__content"><select onchange="if(this.value) window.location.href=this.value" class="input-select input-select_small tablet-menu__nav"><option value="/tutorial" selected>Tutorial</option><option value="/courses">Courses</option></select></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><form action="http://javascript.info/search/" class="tablet-menu-search"><input type="search" name="query" placeholder="Search in the tutorial" required class="tablet-menu-search__input"><button type="submit" name="type" value="articles" class="tablet-menu-search__button">Search</button></form></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><a href="tutorial/map.html" data-action="tutorial-map" class="map"><span class="map__text">Tutorial map</span></a></div></div><!--+e.line--><!--  +e.content--><!--    +b("a").tablet-ebook(href="/ebook")--><!--      +e("span").text Купить учебник--><!--      +e("span").note (EPUB + PDF)--><div class="tablet-menu__line"><div class="tablet-menu__content"><div class="share-icons"><span class="share-icons__title">Share</span><a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fpromise-chaining" class="share share_tw"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fpromise-chaining" class="share share_fb"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fpromise-chaining" class="share share_gp"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fpromise-chaining" class="share share_vk"></a></div></div></div></div><progress data-sticky value="3" max="5" data-tooltip="Lesson 3 of 5" class="tutorial-progress"></progress></div><div class="page page_sidebar_on"><script>if(localStorage.noSidebar){document.querySelector(".page").classList.remove("page_sidebar_on");var pageWrapper=document.querySelector(".page-wrapper");pageWrapper&&pageWrapper.classList.remove("page-wrapper_sidebar_on")}setTimeout(function(){document.querySelector(".page").classList.add("page_sidebar-animation-on")},0);</script><div class="page__inner"><main class="main main_width-limit"><header class="main__header"><div class="main__header-inner"><ol class="breadcrumbs"><li itemscope itemtype="http://data-vocabulary.org/Breadcrumb" itemref="breadcrumb-1" class="breadcrumbs__item breadcrumbs__item_home"><a href="index.html" itemprop="url" class="breadcrumbs__link"><span itemprop="title" class="breadcrumbs__hidden-text">Tutorial</span></a></li><li id="breadcrumb-1" itemscope itemtype="http://data-vocabulary.org/Breadcrumb" itemprop="child" class="breadcrumbs__item"><a href="async.html" itemprop="url" class="breadcrumbs__link"><span itemprop="title">Promises, async/await</span></a></li></ol><h1 class="main__header-title">Promises chaining</h1></div></header><div class="content"><article itemscope itemtype="http://schema.org/TechArticle"><meta itemprop="name" content="Promises chaining"><div itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="email" content="iliakan@gmail.com"><meta itemprop="name" content="Ilya Kantor"></div><div itemprop="articleBody"><p>Let’s return to the problem mentioned in the chapter <a href="callbacks.html">Introduction: callbacks</a>.</p>
<ul>
<li>We have a sequence of asynchronous tasks to be done one after another. For instance, loading scripts.</li>
<li>How to code it well?</li>
</ul>
<p>Promises provide a couple of recipes to do that.</p>
<p>In this chapter we cover promise chaining.</p>
<p>It looks like this:</p>
<div data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">new Promise(function(resolve, reject) {

  setTimeout(() =&gt; resolve(1), 1000); // (*)

}).then(function(result) { // (**)

  alert(result); // 1
  return result * 2;

}).then(function(result) { // (***)

  alert(result); // 2
  return result * 2;

}).then(function(result) {

  alert(result); // 4
  return result * 2;

});</code></pre>
        </div>
      </div>
      
      </div><p>The idea is that the result is passed through the chain of <code>.then</code> handlers.</p>
<p>Here the flow is:</p>
<ol>
<li>The initial promise resolves in 1 second <code>(*)</code>,</li>
<li>Then the <code>.then</code> handler is called <code>(**)</code>.</li>
<li>The value that it returns is passed to the next <code>.then</code> handler <code>(***)</code></li>
<li>…and so on.</li>
</ol>
<p>As the result is passed along the chain of handlers, we can see a sequence of <code>alert</code> calls: <code>1</code> → <code>2</code> → <code>4</code>.</p>
<figure><div class="image" style="width:141px">
      <div class="image__ratio" style="padding-top:225.531914893617%"></div>
      <img src="article/promise-chaining/promise-then-chain.png" alt="" width="141" height="318" class="image__image">
      </div></figure><p>The whole thing works, because a call to <code>promise.then</code> returns a promise, so that we can call the next <code>.then</code> on it.</p>
<p>When a handler returns a value, it becomes the result of that promise, so the next <code>.then</code> is called with it.</p>
<p>To make these words more clear, here’s the start of the chain:</p>
<div data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">new Promise(function(resolve, reject) {

  setTimeout(() =&gt; resolve(1), 1000);

}).then(function(result) {

  alert(result);
  return result * 2; // &lt;-- (1)

}) // &lt;-- (2)
// .then…</code></pre>
        </div>
      </div>
      
      </div><p>The value returned by <code>.then</code> is a promise, that’s why we are able to add another <code>.then</code> at <code>(2)</code>. When the value is returned in <code>(1)</code>, that promise becomes resolved, so the next handler runs with the value.</p>
<p>Unlike the chaining, technically we can also add many <code>.then</code> to a single promise, like this:</p>
<div data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">let promise = new Promise(function(resolve, reject) {
  setTimeout(() =&gt; resolve(1), 1000);
});

promise.then(function(result) {
  alert(result); // 1
  return result * 2;
});

promise.then(function(result) {
  alert(result); // 1
  return result * 2;
});

promise.then(function(result) {
  alert(result); // 1
  return result * 2;
});</code></pre>
        </div>
      </div>
      
      </div><p>…But that’s a totally different thing. Here’s the picture (compare it with the chaining above):</p>
<figure><div class="image" style="width:355px">
      <div class="image__ratio" style="padding-top:41.12676056338028%"></div>
      <img src="article/promise-chaining/promise-then-many.png" alt="" width="355" height="146" class="image__image">
      </div></figure><p>All <code>.then</code> on the same promise get the same result – the result of that promise. So in the code above all <code>alert</code> show the same: <code>1</code>. There is no result-passing between them.</p>
<p>In practice we rarely need multiple handlers for one promise. Chaining is used much more often.</p>
<h2><a class="main__anchor" name="returning-promises" href="#returning-promises">Returning promises</a></h2><p>Normally, a value returned by a <code>.then</code> handler is immediately passed to the next handler. But there’s an exception.</p>
<p>If the returned value is a promise, then the further execution is suspended until it settles. After that, the result of that promise is given to the next <code>.then</code> handler.</p>
<p>For instance:</p>
<div data-trusted="1" class="code-example" data-highlight-block="8-10">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">new Promise(function(resolve, reject) {

  setTimeout(() =&gt; resolve(1), 1000);

}).then(function(result) {

  alert(result); // 1

  return new Promise((resolve, reject) =&gt; { // (*)
    setTimeout(() =&gt; resolve(result * 2), 1000);
  });

}).then(function(result) { // (**)

  alert(result); // 2

  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; resolve(result * 2), 1000);
  });

}).then(function(result) {

  alert(result); // 4

});</code></pre>
        </div>
      </div>
      
      </div><p>Here the first <code>.then</code> shows <code>1</code> returns <code>new Promise(…)</code> in the line <code>(*)</code>. After one second it resolves, and the result (the argument of <code>resolve</code>, here it’s <code>result*2</code>) is passed on to handler of the second <code>.then</code> in the line <code>(**)</code>. It shows <code>2</code> and does the same thing.</p>
<p>So the output is again 1 → 2 → 4, but now with 1 second delay between <code>alert</code> calls.</p>
<p>Returning promises allows us to build chains of asynchronous actions.</p>
<h2><a class="main__anchor" name="example-loadscript" href="#example-loadscript">Example: loadScript</a></h2><p>Let’s use this feature with <code>loadScript</code> to load scripts one by one, in sequence:</p>
<div data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">loadScript(&quot;/article/promise-chaining/one.js&quot;)
  .then(function(script) {
    return loadScript(&quot;/article/promise-chaining/two.js&quot;);
  })
  .then(function(script) {
    return loadScript(&quot;/article/promise-chaining/three.js&quot;);
  })
  .then(function(script) {
    // use functions declared in scripts
    // to show that they indeed loaded
    one();
    two();
    three();
  });</code></pre>
        </div>
      </div>
      
      </div><p>Here each <code>loadScript</code> call returns a promise, and the next <code>.then</code> runs when it resolves. Then it initiates the loading of the next script. So scripts are loaded one after another.</p>
<p>We can add more asynchronous actions to the chain. Please note that code is still “flat”, it grows down, not to the right. There are no signs of “pyramid of doom”.</p>
<p>Please note that technically it is also possible to write <code>.then</code> directly after each promise, without returning them, like this:</p>
<div data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">loadScript(&quot;/article/promise-chaining/one.js&quot;).then(function(script1) {
  loadScript(&quot;/article/promise-chaining/two.js&quot;).then(function(script2) {
    loadScript(&quot;/article/promise-chaining/three.js&quot;).then(function(script3) {
      // this function has access to variables script1, script2 and script3
      one();
      two();
      three();
    });
  });
});</code></pre>
        </div>
      </div>
      
      </div><p>This code does the same: loads 3 scripts in sequence. But it “grows to the right”. So we have the same problem as with callbacks. Use chaining (return promises from <code>.then</code>) to evade it.</p>
<p>Sometimes it’s ok to write <code>.then</code> directly, because the nested function has access to the outer scope (here the most nested callback has access to all variables <code>scriptX</code>), but that’s an exception rather than a rule.</p>
<div class="important important_smart">
            <div class="important__header"><span class="important__type">Thenables</span></div>
            <div class="important__content"><p>To be precise, <code>.then</code> may return an arbitrary “thenable” object, and it will be treated the same way as a promise.</p>
<p>A “thenable” object is any object with a method <code>.then</code>.</p>
<p>The idea is that 3rd-party libraries may implement “promise-compatible” objects of their own. They can have extended set of methods, but also be compatible with native promises, because they implement <code>.then</code>.</p>
<p>Here’s an example of a thenable object:</p>
<div data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">class Thenable {
  constructor(num) {
    this.num = num;
  }
  then(resolve, reject) {
    alert(resolve); // function() { native code }
    // resolve with this.num*2 after the 1 second
    setTimeout(() =&gt; resolve(this.num * 2), 1000); // (**)
  }
}

new Promise(resolve =&gt; resolve(1))
  .then(result =&gt; {
    return new Thenable(result); // (*)
  })
  .then(alert); // shows 2 after 1000ms</code></pre>
        </div>
      </div>
      
      </div><p>JavaScript checks the object returned by <code>.then</code> handler in the line <code>(*)</code>: if it has a callable method named <code>then</code>, then it calls that method providing native functions <code>resolve</code>, <code>reject</code> as arguments (similar to executor) and waits until one of them is called. In the example above <code>resolve(2)</code> is called after 1 second <code>(**)</code>. Then the result is passed further down the chain.</p>
<p>This feature allows to integrate custom objects with promise chains without having to inherit from <code>Promise</code>.</p>
</div></div>
<h2><a class="main__anchor" name="bigger-example-fetch" href="#bigger-example-fetch">Bigger example: fetch</a></h2><p>In frontend programming promises are often used for network requests. So let’s see an extended example of that.</p>
<p>We’ll use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch">fetch</a> method to load the information about the user from the remote server. The method is quite complex, it has many optional parameters, but the basic usage is quite simple:</p>
<div data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">let promise = fetch(url);</code></pre>
        </div>
      </div>
      
      </div><p>This makes a network request to the <code>url</code> and returns a promise. The promise resolves with a <code>response</code> object when the remote server responds with headers, but <em>before the full response is downloaded</em>.</p>
<p>To read the full response, we should call a method <code>response.text()</code>: it returns a promise that resolves  when the full text downloaded from the remote server, with that text as a result.</p>
<p>The code below makes a request to <code>user.json</code> and loads its text from the server:</p>
<div data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">fetch('/article/promise-chaining/user.json')
  // .then below runs when the remote server responds
  .then(function(response) {
    // response.text() returns a new promise that resolves with the full response text
    // when we finish downloading it
    return response.text();
  })
  .then(function(text) {
    // ...and here's the content of the remote file
    alert(text); // {&quot;name&quot;: &quot;iliakan&quot;, isAdmin: true}
  });</code></pre>
        </div>
      </div>
      
      </div><p>There is also a method <code>response.json()</code> that reads the remote data and parses it as JSON. In our case that’s even more convenient, so let’s switch to it.</p>
<p>We’ll also use arrow functions for brevity:</p>
<div data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">// same as above, but response.json() parses the remote content as JSON
fetch('/article/promise-chaining/user.json')
  .then(response =&gt; response.json())
  .then(user =&gt; alert(user.name)); // iliakan</code></pre>
        </div>
      </div>
      
      </div><p>Now let’s do something with the loaded user.</p>
<p>For instance, we can make one more request to github, load the user profile and show the avatar:</p>
<div data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">// Make a request for user.json
fetch('/article/promise-chaining/user.json')
  // Load it as json
  .then(response =&gt; response.json())
  // Make a request to github
  .then(user =&gt; fetch(`https://api.github.com/users/${user.name}`))
  // Load the response as json
  .then(response =&gt; response.json())
  // Show the avatar image (githubUser.avatar_url) for 3 seconds (maybe animate it)
  .then(githubUser =&gt; {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = &quot;promise-avatar-example&quot;;
    document.body.append(img);

    setTimeout(() =&gt; img.remove(), 3000); // (*)
  });</code></pre>
        </div>
      </div>
      
      </div><p>The code works, see comments about the details, but it should be quite self-descriptive. Although, there’s a potential problem in it, a typical error of those who begin to use promises.</p>
<p>Look at the line <code>(*)</code>: how can we do something <em>after</em> the avatar has finished showing and gets removed? For instance, we’d like to show a form for editing that user or something else. As of now, there’s no way.</p>
<p>To make the chain extendable, we need to return a promise that resolves when the avatar finishes showing.</p>
<p>Like this:</p>
<div data-trusted="1" class="code-example" data-highlight-block="4-4,12-12">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">fetch('/article/promise-chaining/user.json')
  .then(response =&gt; response.json())
  .then(user =&gt; fetch(`https://api.github.com/users/${user.name}`))
  .then(response =&gt; response.json())
  .then(githubUser =&gt; new Promise(function(resolve, reject) {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = &quot;promise-avatar-example&quot;;
    document.body.append(img);

    setTimeout(() =&gt; {
      img.remove();
      resolve(githubUser);
    }, 3000);
  }))
  // triggers after 3 seconds
  .then(githubUser =&gt; alert(`Finished showing ${githubUser.name}`));</code></pre>
        </div>
      </div>
      
      </div><p>Now right after <code>setTimeout</code> runs <code>img.remove()</code>, it calls <code>resolve(githubUser)</code>, thus passing the control to the next <code>.then</code> in the chain and passing forward the user data.</p>
<p>As a rule, an asynchronous action should always return a promise.</p>
<p>That makes possible to plan actions after it. Even if we don’t plan to extend the chain now, we may need it later.</p>
<p>Finally, we can split the code into reusable functions:</p>
<div data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">function loadJson(url) {
  return fetch(url)
    .then(response =&gt; response.json());
}

function loadGithubUser(name) {
  return fetch(`https://api.github.com/users/${name}`)
    .then(response =&gt; response.json());
}

function showAvatar(githubUser) {
  return new Promise(function(resolve, reject) {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = &quot;promise-avatar-example&quot;;
    document.body.append(img);

    setTimeout(() =&gt; {
      img.remove();
      resolve(githubUser);
    }, 3000);
  });
}

// Use them:
loadJson('/article/promise-chaining/user.json')
  .then(user =&gt; loadGithubUser(user.name))
  .then(showAvatar)
  .then(githubUser =&gt; alert(`Finished showing ${githubUser.name}`));
  // ...</code></pre>
        </div>
      </div>
      
      </div><h2><a class="main__anchor" name="error-handling" href="#error-handling">Error handling</a></h2><p>Asynchronous actions may sometimes fail: in case of an error the corresponding promise becomes rejected. For instance, <code>fetch</code> fails if the remote server is not available. We can use <code>.catch</code> to handle errors (rejections).</p>
<p>Promise chaining is great at that aspect. When a promise rejects, the control jumps to the closest rejection handler down the chain. That’s very convenient in practice.</p>
<p>For instance, in the code below the URL is wrong (no such server) and <code>.catch</code> handles the error:</p>
<div data-trusted="1" class="code-example" data-highlight-block="0-0">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">fetch('https://no-such-server.blabla') // rejects
  .then(response =&gt; response.json())
  .catch(err =&gt; alert(err)) // TypeError: failed to fetch (the text may vary)</code></pre>
        </div>
      </div>
      
      </div><p>Or, maybe, everything is all right with the server, but the response is not a valid JSON:</p>
<div data-trusted="1" class="code-example" data-highlight-block="1-1">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">fetch('/') // fetch works fine now, the server responds successfully
  .then(response =&gt; response.json()) // rejects: the page is HTML, not a valid json
  .catch(err =&gt; alert(err)) // SyntaxError: Unexpected token &lt; in JSON at position 0</code></pre>
        </div>
      </div>
      
      </div><p>In the example below we append <code>.catch</code> to handle all errors in the avatar-loading-and-showing chain:</p>
<div data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">fetch('/article/promise-chaining/user.json')
  .then(response =&gt; response.json())
  .then(user =&gt; fetch(`https://api.github.com/users/${user.name}`))
  .then(response =&gt; response.json())
  .then(githubUser =&gt; new Promise(function(resolve, reject) {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = &quot;promise-avatar-example&quot;;
    document.body.append(img);

    setTimeout(() =&gt; {
      img.remove();
      resolve(githubUser);
    }, 3000);
  }))
  .catch(error =&gt; alert(error.message));</code></pre>
        </div>
      </div>
      
      </div><p>Here <code>.catch</code> doesn’t trigger at all, because there are no errors. But if any of the promises above rejects, then it would execute.</p>
<h2><a class="main__anchor" name="implicit-try-catch" href="#implicit-try-catch">Implicit try…catch</a></h2><p>The code of the executor and promise handlers has an &quot;invisible <code>try..catch</code>&quot; around it. If an error happens, it gets caught and treated as a rejection.</p>
<p>For instance, this code:</p>
<div data-trusted="1" class="code-example" data-highlight-block="1-1">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">new Promise(function(resolve, reject) {
  throw new Error(&quot;Whoops!&quot;);
}).catch(alert); // Error: Whoops!</code></pre>
        </div>
      </div>
      
      </div><p>…Works the same way as this:</p>
<div data-trusted="1" class="code-example" data-highlight-block="1-1">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">new Promise(function(resolve, reject) {
  reject(new Error(&quot;Whoops!&quot;));
}).catch(alert); // Error: Whoops!</code></pre>
        </div>
      </div>
      
      </div><p>The &quot;invisible <code>try..catch</code>&quot; around the executor automatically catches the error and treats it as a rejection.</p>
<p>That’s so not only in the executor, but in handlers as well. If we <code>throw</code> inside <code>.then</code> handler, that means a rejected promise, so the control jumps to the nearest error handler.</p>
<p>Here’s an example:</p>
<div data-trusted="1" class="code-example" data-highlight-block="3-3">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">new Promise(function(resolve, reject) {
  resolve(&quot;ok&quot;);
}).then(function(result) {
  throw new Error(&quot;Whoops!&quot;); // rejects the promise
}).catch(alert); // Error: Whoops!</code></pre>
        </div>
      </div>
      
      </div><p>That’s so not only for <code>throw</code>, but for any errors, including programming errors as well:</p>
<div data-trusted="1" class="code-example" data-highlight-block="3-3">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">new Promise(function(resolve, reject) {
  resolve(&quot;ok&quot;);
}).then(function(result) {
  blabla(); // no such function
}).catch(alert); // ReferenceError: blabla is not defined</code></pre>
        </div>
      </div>
      
      </div><p>As a side effect, the final <code>.catch</code> not only catches explicit rejections, but also occasional errors in the handlers above.</p>
<h2><a class="main__anchor" name="rethrowing" href="#rethrowing">Rethrowing</a></h2><p>As we already noticed, <code>.catch</code> behaves like <code>try..catch</code>. We may have as many <code>.then</code> as we want, and then use a single <code>.catch</code> at the end to handle errors in all of them.</p>
<p>In a regular <code>try..catch</code> we can analyze the error and maybe rethrow it if can’t handle. The same thing is possible for promises. If we <code>throw</code> inside <code>.catch</code>, then the control goes to the next closest error handler. And if we handle the error and finish normally, then it continues to the closest successful <code>.then</code> handler.</p>
<p>In the example below the <code>.catch</code> successfully handles the error:</p>
<div data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">// the execution: catch -&gt; then
new Promise(function(resolve, reject) {

  throw new Error(&quot;Whoops!&quot;);

}).catch(function(error) {

  alert(&quot;The error is handled, continue normally&quot;);

}).then(() =&gt; alert(&quot;Next successful handler runs&quot;));</code></pre>
        </div>
      </div>
      
      </div><p>Here the <code>.catch</code> block finishes normally. So the next successful handler is called. Or it could return something, that would be the same.</p>
<p>…And here the <code>.catch</code> block analyzes the error and throws it again:</p>
<div data-trusted="1" class="code-example" data-highlight-block="12-12">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">// the execution: catch -&gt; catch -&gt; then
new Promise(function(resolve, reject) {

  throw new Error(&quot;Whoops!&quot;);

}).catch(function(error) { // (*)

  if (error instanceof URIError) {
    // handle it
  } else {
    alert(&quot;Can't handle such error&quot;);

    throw error; // throwing this or another error jumps to the next catch
  }

}).then(function() {
  /* never runs here */
}).catch(error =&gt; { // (**)

  alert(`The unknown error has occurred: ${error}`);
  // don't return anything =&gt; execution goes the normal way

});</code></pre>
        </div>
      </div>
      
      </div><p>The handler <code>(*)</code> catches the error and just can’t handle it, because it’s not <code>URIError</code>, so it throws it again. Then the execution jumps to the next <code>.catch</code> down the chain <code>(**)</code>.</p>
<p>In the section below we’ll see a practical example of rethrowing.</p>
<h2><a class="main__anchor" name="fetch-error-handling-example" href="#fetch-error-handling-example">Fetch error handling example</a></h2><p>Let’s improve error handling for the user-loading example.</p>
<p>The promise returned by <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch">fetch</a> rejects when it’s impossible to make a request. For instance, a remote server is not available, or the URL is malformed. But if the remote server responds with error 404, or even error 500, then it’s considered a valid response.</p>
<p>What if the server returns a non-JSON page with error 500 in the line <code>(*)</code>? What if there’s no such user, and github returns a page with error 404 at <code>(**)</code>?</p>
<div data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">fetch('no-such-user.json') // (*)
  .then(response =&gt; response.json())
  .then(user =&gt; fetch(`https://api.github.com/users/${user.name}`)) // (**)
  .then(response =&gt; response.json())
  .catch(alert); // SyntaxError: Unexpected token &lt; in JSON at position 0
  // ...</code></pre>
        </div>
      </div>
      
      </div><p>As of now, the code tries to load the response as JSON no matter what and dies with a syntax error. You can see that by running the example above, as the file <code>no-such-user.json</code> doesn’t exist.</p>
<p>That’s not good, because the error just falls through the chain, without details: what failed and where.</p>
<p>So let’s add one more step: we should check the <code>response.status</code> property that has HTTP status, and if it’s not 200, then throw an error.</p>
<div data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">class HttpError extends Error { // (1)
  constructor(response) {
    super(`${response.status} for ${response.url}`);
    this.name = 'HttpError';
    this.response = response;
  }
}

function loadJson(url) { // (2)
  return fetch(url)
    .then(response =&gt; {
      if (response.status == 200) {
        return response.json();
      } else {
        throw new HttpError(response);
      }
    })
}

loadJson('no-such-user.json') // (3)
  .catch(alert); // HttpError: 404 for .../no-such-user.json</code></pre>
        </div>
      </div>
      
      </div><ol>
<li>We make a custom class for HTTP Errors to distinguish them from other types of errors. Besides, the new class has a constructor that accepts the <code>response</code> object and saves it in the error. So error-handling code will be able to access it.</li>
<li>Then we put together the requesting and error-handling code into a function that fetches the <code>url</code> <em>and</em> treats any non-200 status as an error. That’s convenient, because we often need such logic.</li>
<li>Now <code>alert</code> shows better message.</li>
</ol>
<p>The great thing about having our own class for errors is that we can easily check for it in error-handling code.</p>
<p>For instance, we can make a request, and then if we get 404 – ask the user to modify the information.</p>
<p>The code below loads a user with the given name from github. If there’s no such user, then it asks for the correct name:</p>
<div data-trusted="1" class="code-example" data-highlight-block="9-9">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">function demoGithubUser() {
  let name = prompt(&quot;Enter a name?&quot;, &quot;iliakan&quot;);

  return loadJson(`https://api.github.com/users/${name}`)
    .then(user =&gt; {
      alert(`Full name: ${user.name}.`); // (1)
      return user;
    })
    .catch(err =&gt; {
      if (err instanceof HttpError &amp;&amp; err.response.status == 404) { // (2)
        alert(&quot;No such user, please reenter.&quot;);
        return demoGithubUser();
      } else {
        throw err;
      }
    });
}

demoGithubUser();</code></pre>
        </div>
      </div>
      
      </div><p>Here:</p>
<ol>
<li>If <code>loadJson</code> returns a valid user object, then the name is shown <code>(1)</code>, and the user is returned, so that we can add more user-related actions to the chain. In that case the <code>.catch</code> below is ignored, everything’s very simple and fine.</li>
<li>Otherwise, in case of an error, we check it in the line <code>(2)</code>. Only if it’s indeed the HTTP error, and the status is 404 (Not found), we ask the user to reenter. For other errors – we don’t know how to handle, so we just rethrow them.</li>
</ol>
<h2><a class="main__anchor" name="unhandled-rejections" href="#unhandled-rejections">Unhandled rejections</a></h2><p>What happens when an error is not handled? For instance, after the rethrow as in the example above. Or if we forget to append an error handler to the end of the chain, like here:</p>
<div data-trusted="0" class="code-example" data-refresh="1">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">new Promise(function() {
  noSuchFunction(); // Error here (no such function)
}); // no .catch attached</code></pre>
        </div>
      </div>
      
      </div><p>Or here:</p>
<div data-trusted="0" class="code-example" data-refresh="1">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">// a chain of promises without .catch at the end
new Promise(function() {
  throw new Error(&quot;Whoops!&quot;);
}).then(function() {
  // ...something...
}).then(function() {
  // ...something else...
}).then(function() {
  // ...but no catch after it!
});</code></pre>
        </div>
      </div>
      
      </div><p>In case of an error, the promise state becomes “rejected”, and the execution should jump to the closest rejection handler. But there is no such handler in the examples above. So the error gets “stuck”.</p>
<p>In practice, that’s usually because of the bad code. Indeed, how come that there’s no error handling?</p>
<p>Most JavaScript engines track such situations and generate a global error in that case. We can see it in the console.</p>
<p>In the browser we can catch it using the event <code>unhandledrejection</code>:</p>
<div data-trusted="1" class="code-example" data-highlight-block="0-4">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">window.addEventListener('unhandledrejection', function(event) {
  // the event object has two special properties:
  alert(event.promise); // [object Promise] - the promise that generated the error
  alert(event.reason); // Error: Whoops! - the unhandled error object
});

new Promise(function() {
  throw new Error(&quot;Whoops!&quot;);
}); // no catch to handle the error</code></pre>
        </div>
      </div>
      
      </div><p>The event is the part of the <a href="https://html.spec.whatwg.org/multipage/webappapis.html#unhandled-promise-rejections">HTML standard</a>. Now if an error occurs, and there’s no <code>.catch</code>, the <code>unhandledrejection</code> handler triggers: the <code>event</code> object has the information about the error, so we can do something with it.</p>
<p>Usually such errors are unrecoverable, so our best way out is to inform the user about the problem and probably report about the incident to the server.</p>
<p>In non-browser environments like Node.JS there are other similar ways to track unhandled errors.</p>
<h2><a class="main__anchor" name="summary" href="#summary">Summary</a></h2><p>To summarize, <code>.then/catch(handler)</code> returns a new promise that changes depending on what handler does:</p>
<ol>
<li>If it returns a value or finishes without a <code>return</code> (same as <code>return undefined</code>), then the new promise becomes resolved, and the closest resolve handler (the first argument of <code>.then</code>) is called with that value.</li>
<li>If it throws an error, then the new promise becomes rejected, and the closest rejection handler (second argument of <code>.then</code> or <code>.catch</code>) is called with it.</li>
<li>If it returns a promise, then JavaScript waits until it settles and then acts on its outcome the same way.</li>
</ol>
<p>The picture of how the promise returned by <code>.then/catch</code> changes:</p>
<figure><div class="image" style="width:685px">
      <div class="image__ratio" style="padding-top:39.270072992700726%"></div>
      <img src="article/promise-chaining/promise-handler-variants.png" alt="" width="685" height="269" class="image__image">
      </div></figure><p>The smaller picture of how handlers are called:</p>
<figure><div class="image" style="width:737px">
      <div class="image__ratio" style="padding-top:21.845318860244234%"></div>
      <img src="article/promise-chaining/promise-handler-variants-2.png" alt="" width="737" height="161" class="image__image">
      </div></figure><p>In the examples of error handling above the <code>.catch</code> was always the last in the chain. In practice though, not every promise chain has a <code>.catch</code>. Just like regular code is not always wrapped in <code>try..catch</code>.</p>
<p>We should place <code>.catch</code> exactly in the places where we want to handle errors and know how to handle them. Using custom error classes can help to analyze errors and rethrow those that we can’t handle.</p>
<p>For errors that fall outside of our scope we should have the <code>unhandledrejection</code> event handler (for browsers, and analogs for other environments). Such unknown errors are usually unrecoverable, so all we should do is to inform the user and probably report to our server about the incident.</p>
</div></article><div class="tasks"><h2 id="tasks" class="tasks__title"><a href="#tasks" class="main__anchor main__anchor_noicon tasks__title-anchor">Tasks</a></h2><div class="task tasks__task"><div class="task__header"><div class="task__title-wrap"><h3 class="task__title"><a href="#promise-then-versus-catch" name="promise-then-versus-catch" class="main__anchor">Promise: then versus catch</a></h3><a href="task/then-vs-catch.html" target="_blank" class="task__open-link"></a></div><div class="task__header-note"></div><div class="task__content"><p>Are these code fragments equal? In other words, do they behave the same way in any circumstances, for any handler functions?</p>
<div data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">promise.then(f1, f2);</code></pre>
        </div>
      </div>
      
      </div><p>Versus;</p>
<div data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">promise.then(f1).catch(f2);</code></pre>
        </div>
      </div>
      
      </div><button type="button" class="task__solution">solution</button><div class="task__answer"><div class="task__answer-content"><p>The short answer is: <strong>no, they are not the equal</strong>:</p>
<p>The difference is that if an error happens in <code>f1</code>, then it is handled by <code>.catch</code> here:</p>
<div data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">promise
  .then(f1)
  .catch(f2);</code></pre>
        </div>
      </div>
      
      </div><p>…But not here:</p>
<div data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">promise
  .then(f1, f2);</code></pre>
        </div>
      </div>
      
      </div><p>That’s because an error is passed down the chain, and in the second code piece there’s no chain below <code>f1</code>.</p>
<p>In other words, <code>.then</code> passes results/errors to the next <code>.then/catch</code>. So in the first example, there’s a <code>catch</code> below, and in the second one – there isn’t, so the error is unhandled.</p>
</div><button type="button" title="close" class="close-button task__answer-close"></button></div></div></div></div><div class="task tasks__task"><div class="task__header"><div class="task__title-wrap"><h3 class="task__title"><a href="#error-in-settimeout" name="error-in-settimeout" class="main__anchor">Error in setTimeout</a></h3><a href="task/error-async.html" target="_blank" class="task__open-link"></a></div><div class="task__header-note"></div><div class="task__content"><p>What do you think? Will the <code>.catch</code> trigger? Explain your answer.</p>
<div data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">new Promise(function(resolve, reject) {
  setTimeout(() =&gt; {
    throw new Error(&quot;Whoops!&quot;);
  }, 1000);
}).catch(alert);</code></pre>
        </div>
      </div>
      
      </div><button type="button" class="task__solution">solution</button><div class="task__answer"><div class="task__answer-content"><p>The answer is: <strong>no, it won’t</strong>:</p>
<div data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="#" title="run" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="#" title="open in sandbox" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code class="language-javascript">new Promise(function(resolve, reject) {
  setTimeout(() =&gt; {
    throw new Error(&quot;Whoops!&quot;);
  }, 1000);
}).catch(alert);</code></pre>
        </div>
      </div>
      
      </div><p>As said in the chapter, there’s an &quot;implicit <code>try..catch</code>&quot; around the function code. So all synchronous errors are handled.</p>
<p>But here the error is generated not while the executor is running, but later. So the promise can’t handle it.</p>
</div><button type="button" title="close" class="close-button task__answer-close"></button></div></div></div></div></div><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en--></div><div class="page__nav-wrap"><a href="promise-basics.html" data-tooltip="Promise" class="page__nav page__nav_prev"><span class="page__nav-text"><span class="page__nav-text-shortcut"></span></span><span class="page__nav-text-alternate">Previous lesson</span></a><a href="promise-api.html" data-tooltip="Promise API" class="page__nav page__nav_next"><span class="page__nav-text"><span class="page__nav-text-shortcut"></span></span><span class="page__nav-text-alternate">Next lesson</span></a></div><div class="article-tablet-foot tablet-only"><div class="article-tablet-foot__layout"><div class="share-icons"><span class="share-icons__title">Share</span><a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fpromise-chaining" class="share share_tw"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fpromise-chaining" class="share share_fb"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fpromise-chaining" class="share share_gp"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fpromise-chaining" class="share share_vk"></a></div><div class="article-tablet-foot__map"><a href="tutorial/map.html" data-action="tutorial-map" class="map"><span class="map__text">Tutorial map</span></a></div></div></div><div id="comments" class="comments"><div class="comments__header"><h2 class="comments__header-title"><a href="#comments" name="comments">Comments</a></h2><div class="comments__read-before"><span class="comments__read-before-link">read this before commenting…</span><div class="comments__read-before-popup"><div class="comments__read-before-popup-i"><ul><li>You're welcome to post additions, questions to the articles and answers to them.</li><li>To insert a few words of code, use the <code>&lt;code&gt;</code> tag, for several lines – use <code>&lt;pre&gt;</code>, for more than 10 lines – use a sandbox (<a href='http://plnkr.co/edit/?p=preview'>plnkr</a>, <a href='http://jsbin.com/'>JSBin</a>, <a href='http://codepen.io/'>codepen</a>…)</li><li>If you can't understand something in the article – please elaborate.</li></ul></div></div></div></div></div><div id="disqus_thread"></div><script>var disqus_config = function() { if (!this.page) this.page = {}; Object.assign(this.page, {"url":"https:\/\/javascript.info\/promise-chaining","identifier":"\/promise-chaining","title":"Promises chaining"}); };</script><script>var disqus_shortname = "javascriptinfo";</script><script>var disqus_enabled = true;</script></main></div><div class="page__sidebar sidebar sidebar_sticky-footer"><button data-sidebar-toggle class="sidebar__toggle"></button><a href="tutorial/map.html" data-action="tutorial-map" data-tooltip="Tutorial map" class="map"></a><div class="sidebar__inner"><div class="sidebar__content"><div class="sidebar__section"><h4 class="sidebar__section-title">Chapter</h4><nav class="sidebar__navigation"><ul class="sidebar__navigation-links"><li class="sidebar__navigation-link"><a href="async.html" class="sidebar__link">Promises, async/await</a></li></ul></nav></div><div class="sidebar__section"><h4 class="sidebar__section-title">Lesson navigation</h4><nav class="sidebar__navigation"><ul class="sidebar__navigation-links"><li class="sidebar__navigation-link"><a href="#returning-promises" class="sidebar__link">Returning promises</a></li><li class="sidebar__navigation-link"><a href="#example-loadscript" class="sidebar__link">Example: loadScript</a></li><li class="sidebar__navigation-link"><a href="#bigger-example-fetch" class="sidebar__link">Bigger example: fetch</a></li><li class="sidebar__navigation-link"><a href="#error-handling" class="sidebar__link">Error handling</a></li><li class="sidebar__navigation-link"><a href="#implicit-try-catch" class="sidebar__link">Implicit try…catch</a></li><li class="sidebar__navigation-link"><a href="#rethrowing" class="sidebar__link">Rethrowing</a></li><li class="sidebar__navigation-link"><a href="#fetch-error-handling-example" class="sidebar__link">Fetch error handling example</a></li><li class="sidebar__navigation-link"><a href="#unhandled-rejections" class="sidebar__link">Unhandled rejections</a></li><li class="sidebar__navigation-link"><a href="#summary" class="sidebar__link">Summary</a></li></ul></nav></div><div class="sidebar__section"><nav class="sidebar__navigation"><ul class="sidebar__navigation-links"><li class="sidebar__navigation-link"><a href="#tasks" class="sidebar__link">Tasks (2)</a></li><li class="sidebar__navigation-link"><a href="#comments" class="sidebar__link">Comments</a></li></ul></nav></div><div class="sidebar__section"><div class="sidebar__section-title">Share</div><a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fpromise-chaining" class="share share_tw sidebar__share"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fpromise-chaining" class="share share_fb sidebar__share"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fpromise-chaining" class="share share_gp sidebar__share"></a></div><div class="sidebar__section"><a href="https://github.com/iliakan/javascript-tutorial-en/tree/master/6-async/03-promise-chaining/article.md" class="sidebar__link">Edit on Github</a></div></div></div></div></div></div><div class="page-footer"><div class="page-footer__left"><ul class="page-footer__list"><li class="page-footer__item">©&nbsp;2007—2018&nbsp; Ilya Kantor</li><li class="page-footer__item"><a href="about.html#contact-us" class="page-footer__link">contact us</a></li><li class="page-footer__item"><a href="about.html" class="page-footer__link">about the project</a></li><li class="page-footer__item"><a href="https://learn.javascript.ru/" class="page-footer__link">RU</a> / EN</li></ul></div><div class="page-footer__right"><ul class="page-footer__list"><li class="page-footer__item">powered by <a rel="nofollow" href="http://nodejs.org/" class="page-footer__link">node.js</a>&nbsp;&amp;&nbsp;<a rel="nofollow" href="http://github.com/iliakan/javascript-tutorial-en" class="page-footer__link">open source</a></li></ul></div></div></body>
<!-- Mirrored from javascript.info/promise-chaining by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 10 Sep 2018 10:51:40 GMT -->
</html>